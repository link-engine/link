# Creating Game Engine

Ever since the start of TP2's assignment, we had one idea in mind: make a program that everyone could make use of to create their own scenes. It started off with the idea that TP2 should be a opportunity to provide code capable of handling every scenario while still providing interactivity with the scene. In that assignment, we developed a scene editor: a GUI capable of interacting with every object in the static scene and change it in the most common ways: shifting its position, rotation, showcasing its wireframe and other ways.

## The Challenge

During our talks with professor, it was suggested that now that we could make any alteration possible to the parser, it would be amazing to give objects a specific behavior via the XML file. With that in mind, little by little we went on to develop our own intricate **game engine**, with lots of functionalities that will be discussed in this document, which are completely decoupled from the scene we've been working parallely in this assignment.

## How it works

To start off, we created our own library - **YAFX** - that generates valid XML, capable of being parser into readable code. YAFX takes simple commands and generates enormous blocks of XML code that would be impossible to write manually. It was a great tool to scale our XML scenes without spending much time doing copy paste of components and writing any line of XML code. Then, the XML code generated by YAFX is parsed by a heavily modified version of the parser given to us at the start of TP2. That parser converts our data into a single *SceneData* object which will then reach the engine.

## What is the Engine and how does it handle data?

The engine's source code is present in the files `MyContents.js` and `MyApp.js`. Each project has their `SceneManager.js`, a class that contain the functions needed to create the various scenes associated to a project. Inside our app, this scene manager is then loaded and becomes the sole responsible for interacting with the MyContents object and loading its content.

All data related to a scene needs to be contained in the XML file that is loaded to the MyContents instance:
- So how do we provide complex behaviours to the objects?
- How do the defined objects interact with each other?

These questions will be answered in detail in the following sections:

# Object Scripting

To allow the user great customization over what their object should do, we implemented support for object scripting via the mapping of `.js` files to nodes! Pay attention to the `controller` tag!

```xml
<node id="node-yafx-6" castshadows="false" receiveshadows="true" controller="../projects/racingGame/scripts/powerup.js" visible="true">
```

These scripts are then loaded as **modules** in the parsing step, and mapped to their corresponding objects after creating the scene's data. These scripts must follow a certain formula, meaning that they should all define three important functions:

- **onStart** - this function will be called after generating the scene's data and loading all the models. It will only be called once.
- **onUpdate** - this function will be called once per frame, and should be used to handle your objects expected behavior.
- **onCollide** - this function will be called when the engine that the object has collided with other object, and should provide the needed logic to handle these events.

With these three functions, objects can now let the engine interact with their properties and provide complex behaviours.

```js
export function onStart({ object, ENGINE }) {

    // Kick-start logic

}

export function onUpdate({ object, ENGINE }) {

    // Main update logic

}


export function onCollide({object, other, ENGINE}) {

    // Complete with logic for collision handling
}

```

# Collision Detection

How do we detect collisions? The user is free to select their preferred way:
- Using [**Rapier Physics Engine**](https://rapier.rs): Rapier Physics Engine has been integrated with our engine to provide fast calculations and physics simulation when needed, loaded as a WASM binary into the application.
- Using our simple collision detection: for the broad phase, the user can define which distance should be used to rule out objects (which should defined in the XML file) and we use Orientend Bounding boxes to check possible intersections between objects of the same Layer

# Layers
Each node (nodes being groups, or objects at the YAFX level) defines which layers they belong to.
```xml
...
    <layers>
        <layer id="1"/>
        <layer id="2"/>
        <layer id="3"/>
    </layers>
</node>
```

Layers can have an `id` and a `name`, but the name is not used at the engine's level. If object `X` is part of layers `1` and `2` it will not collide nor generate collision events with object `Y` that is part of layer `3` and `4`. This is a fast way to rule out collisions between objects the engine level, without the need for calculations and such.

# Events
Lets say you're building a car's racing game. When your car hits the 100 km/h mark, you want the camera to shake. How can you implement this, while **decoupling** the car's logic from the camera? Our solution to that problems comes in the form of **Events**

The engine provides an API to each script so that they can use a few select functions. Each script can access it via the function parameter `ENGINE`.
```js

export function onUpdate({ object, ENGINE }) {

    ENGINE.pushEvent("Superspeed")

}
```

Using our engine's API, you can push tags to the Events pipeline. These are warnings you define that can be mapped to other functions from other scripts via the following syntax:
```js

export function onStart({ object, mixer, eventMap, ENGINE}) {

    ...
    eventMap.get("Superspeed").push(() => onSpeed());
    ...
}

```

Using `eventMap` object, you can map your own functions to a specific event, so that those functions are triggered when that Event shows up in the pipeline:

```js

    const listeners = this.eventMap.get(eventName);

    if (listeners) {
        for (const listener of listeners) {
            listener(event);
        }
    }
```

# API

As we've mentioned before, there are some functionalities hidden behind the engine's API, in case you want to access the scene during the game. These exist so that is possible to create behaviours that could not be created otherwise without the external information, or would be to taxing with the use of events (**for example, make a object follow other object**). 

Other than the remaining objects we provide to the scripts, the API provides these methods:

- *ENGINE.pushEvent()* - send event to the event queue
- *ENGINE.removeObject()* - remove object from the scene
- *ENGINE.addCamera()* - adds camera to the scene
- *ENGINE.changeScene()*- triggers a request to load another scene
- *ENGINE.changeHUD()* - switches the HUD of the active camera
- *ENGINE.getObject()* - gets object of certain *YAFX* id (id given by the client via the XML)
- *ENGINE.getEnv()* - gets environmental variable
- *ENGINE.getClickIntersects()* - gets click events generated by the engine when the user clicks the screen.
- *ENGINE.getMaterial()* - gets material of certain id
- *ENGINE.getNode()* - gets the *YAFX* id of a given object
- *ENGINE.setObject()* - sets new *YAFX* id to given object

The engine also does some heavy work for the user by creating the needed event listeners and generating important events like the clicking of objects and more.

# Global Variables

So far, all ids and information so far must come tied to the scene, described in the XML nodes. But what if we want to describe new values that should be of everyone's access? Thats where `env` variables come into play:

```xml
  <envs>
    <env id="username" type="string" value="Lex"/>
    <env id="difficulty" type="number" value="Medium"/>
  </envs>
```

Access this variables via the provided API to manipulate these values in your scripts.

# Scene Switching

There will be a time where you'll want to create various, distinct levels in your game, and it will be unpractical to describe all logic in one single scene. As mentioned before, each project defines their scene manager for a reason! So that when *"Change Scene"* requests are processed, the engine can help you with the needed flux of data.

In case you want to define variables that should be passed to the next scene, simply include them in you `exports` object, present in the script you mapped to your root object, which can be altered at any point in time:

```js

let exports = {
    activeCar: "green",
    opponentCar: "orange",
    playerName: "Lex",
    level: "Medium",
}

```

The scene manager will take these objects and pass them as context for your next YAFX scene.

# State of The Client

The client (which is the YAFX library, for now) allows for the creation of shaders, simple particles with behaviour, materials, textures, global variables, objects, LODs, HUDs, and complex properties on the definition of cameras, scenes and more! 

With the help of object scripting, **there's virtually no behaviour you can't possibly emulate**.

